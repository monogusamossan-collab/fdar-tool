<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FDARãƒ»SOAP è‡ªå‹•è¨˜éŒ²ãƒ¡ãƒ¼ã‚«ãƒ¼ï½œSOAPç‰ˆ</title>

  <meta name="apple-mobile-web-app-title" content="FDARãƒ»SOAP è‡ªå‹•è¨˜éŒ²ãƒ¡ãƒ¼ã‚«ãƒ¼" />
  <meta name="application-name" content="FDARãƒ»SOAP è‡ªå‹•è¨˜éŒ²ãƒ¡ãƒ¼ã‚«ãƒ¼" />

  <style>
    :root { color-scheme: light dark; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 18px; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    .subTitle { opacity: .85; font-size: 13px; margin: 0 0 14px; line-height: 1.4; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 14px; padding: 14px; }
    label { display:block; font-size: 12px; opacity: .8; margin: 10px 0 6px; }
    input, textarea { width: 100%; box-sizing: border-box; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); padding: 10px 12px; background: rgba(0,0,0,.03); }
    textarea { min-height: 74px; resize: vertical; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btnRow { display:flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    button { border-radius: 14px; padding: 10px 12px; border: 1px solid rgba(127,127,127,.35); background: rgba(0,0,0,.06); cursor:pointer; }
    button.primary { background: rgba(20,120,255,.15); border-color: rgba(20,120,255,.35); }
    .out { margin-top: 14px; }
    pre { white-space: pre-wrap; border-radius: 14px; padding: 12px; border: 1px solid rgba(127,127,127,.25); background: rgba(0,0,0,.04); }
    .warn { margin-top: 10px; opacity: .85; font-size: 12px; line-height: 1.4; }
    .badge { position: fixed; right: 16px; bottom: 70px; z-index: 9999; padding: 8px 10px; border-radius: 12px;
             border: 1px solid rgba(127,127,127,.25); background: rgba(20,20,20,.70); color:#ddd; font-size: 12px; }
    .micBtn { position: fixed; right: 16px; bottom: 16px; z-index: 9999; padding: 12px 14px; border-radius: 14px;
              border: 1px solid rgba(127,127,127,.35); background: rgba(20,20,20,.92); color:#fff; font-size: 14px; }
  </style>
</head>

<body>
  <h1>FDARãƒ»SOAP è‡ªå‹•è¨˜éŒ²ãƒ¡ãƒ¼ã‚«ãƒ¼ï¼ˆSOAPç‰ˆï¼‰</h1>
  <p class="subTitle">æ¬¡ã®è¨ªå•å…ˆã«è¡Œãã¾ã§ã«è‡ªå‹•éŸ³å£°å…¥åŠ›ã€‚è»Šã‚„è‡ªè»¢è»Šç§»å‹•ä¸­ã§ã‚‚ã§ãã¾ã™ï¼</p>

  <div class="card">
    <div class="row">
      <div>
        <label>åˆ©ç”¨è€…ï¼ˆã‚¤ãƒ‹ã‚·ãƒ£ãƒ«æ¨å¥¨ï¼‰</label>
        <input id="client" placeholder="ä¾‹ï¼šAæ§˜ / KM ãªã©ï¼ˆå€‹äººæƒ…å ±ã¯å…¥ã‚Œãªã„é‹ç”¨æ¨å¥¨ï¼‰" />
      </div>
      <div>
        <label>æ—¥ä»˜</label>
        <input id="date" placeholder="YYYY/MM/DD" />
      </div>
    </div>

    <label>S</label>
    <textarea id="s" placeholder="Subjective"></textarea>

    <label>O</label>
    <textarea id="o" placeholder="Objective"></textarea>

    <label>A</label>
    <textarea id="a" placeholder="Assessment"></textarea>

    <label>P</label>
    <textarea id="p" placeholder="Plan"></textarea>

    <div class="btnRow">
      <button class="primary" id="renderCopy">ã‚³ãƒ¼ãƒ‰åŒ–ã—ã¦ã‚³ãƒ”ãƒ¼</button>
      <button id="clearAll">å…¨æ¶ˆå»</button>
      <button id="saveLocal">ã“ã®å†…å®¹ã‚’ä¿å­˜</button>
      <button id="loadLocal">ä¿å­˜ã‚’èª­ã¿è¾¼ã¿</button>
    </div>

    <div class="out">
      <label>å‡ºåŠ›ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</label>
      <pre id="out"></pre>
    </div>

    <div class="warn">
      â€»å€‹äººæƒ…å ±ï¼ˆæ°åãƒ»ä½æ‰€ãƒ»é›»è©±ç•ªå·ãªã©ï¼‰ã¯å…¥åŠ›ã—ãªã„é‹ç”¨ã«ã—ã¦ãã ã•ã„ã€‚<br>
      â€»éŸ³å£°å…¥åŠ›ã¯ç«¯æœ«/ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã‚Šç²¾åº¦ãƒ»å®‰å®šæ€§ãŒç•°ãªã‚Šã¾ã™ï¼ˆChromeæ¨å¥¨ï¼‰ã€‚
    </div>
  </div>

  <div class="badge" id="badge">å¾…æ©Ÿä¸­</div>
  <button class="micBtn" id="micBtn">ğŸ™ éŸ³å£°é–‹å§‹</button>

<script>
(() => {
  const el = {
    client: document.getElementById('client'),
    date: document.getElementById('date'),
    s: document.getElementById('s'),
    o: document.getElementById('o'),
    a: document.getElementById('a'),
    p: document.getElementById('p'),
    out: document.getElementById('out'),
    badge: document.getElementById('badge'),
    micBtn: document.getElementById('micBtn'),
    renderCopy: document.getElementById('renderCopy'),
    clearAll: document.getElementById('clearAll'),
    saveLocal: document.getElementById('saveLocal'),
    loadLocal: document.getElementById('loadLocal'),
  };

  const pad2 = (n) => String(n).padStart(2, '0');
  const today = () => {
    const d = new Date();
    return `${d.getFullYear()}/${pad2(d.getMonth()+1)}/${pad2(d.getDate())}`;
  };

  const speak = (msg) => {
    try {
      if (!('speechSynthesis' in window)) return;
      window.speechSynthesis.cancel();
      const uttr = new SpeechSynthesisUtterance(msg);
      uttr.lang = 'ja-JP';
      uttr.rate = 1.05;
      uttr.pitch = 1.0;
      window.speechSynthesis.speak(uttr);
    } catch {}
  };

  const keyFor = (ini) => `soap_saved_${String(ini || '').trim().toUpperCase()}`;
  const getInitial = () => (el.client.value || '').trim();

  const saveForInitial = (ini, data) => {
    try { localStorage.setItem(keyFor(ini), JSON.stringify(data)); } catch {}
  };
  const loadForInitial = (ini) => {
    try {
      const raw = localStorage.getItem(keyFor(ini));
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  };

  const snapshot = () => ({
    client: el.client.value.trim(),
    date: el.date.value.trim(),
    s: el.s.value,
    o: el.o.value,
    a: el.a.value,
    p: el.p.value,
    updatedAt: Date.now(),
  });

  const fillFromSaved = (saved) => {
    if (!saved) return;
    if (saved.client) el.client.value = saved.client;
    if (saved.date) el.date.value = saved.date;
    el.s.value = saved.s || '';
    el.o.value = saved.o || '';
    el.a.value = saved.a || '';
    el.p.value = saved.p || '';
  };

  const renderText = () => {
    const client = (el.client.value || '').trim();
    const date = (el.date.value || '').trim();
    const S = (el.s.value || '').trim();
    const O = (el.o.value || '').trim();
    const A = (el.a.value || '').trim();
    const P = (el.p.value || '').trim();

    return [
      `# SOAP`,
      date ? `\n${date}` : ``,
      client ? `\n\nã€${client}ã€‘` : ``,
      `\n\n## S\n${S || 'ï¼ˆæœªå…¥åŠ›ï¼‰'}`,
      `\n\n## O\n${O || 'ï¼ˆæœªå…¥åŠ›ï¼‰'}`,
      `\n\n## A\n${A || 'ï¼ˆæœªå…¥åŠ›ï¼‰'}`,
      `\n\n## P\n${P || 'ï¼ˆæœªå…¥åŠ›ï¼‰'}`,
      `\n`
    ].join('');
  };

  const renderAndCopy = async () => {
    const text = renderText();
    el.out.textContent = text;

    const ini = getInitial();
    if (ini) saveForInitial(ini, snapshot());

    try {
      await navigator.clipboard.writeText(text);
      el.badge.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ';
      speak('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
    } catch {
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      el.badge.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ';
      speak('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
    }
  };

  el.renderCopy.addEventListener('click', renderAndCopy);

  el.clearAll.addEventListener('click', () => {
    el.s.value = ''; el.o.value=''; el.a.value=''; el.p.value='';
    el.out.textContent = '';
    el.badge.textContent = 'ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ';
    speak('ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
  });

  el.saveLocal.addEventListener('click', () => {
    const ini = getInitial();
    if (!ini) { alert('åˆ©ç”¨è€…ï¼ˆã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
    saveForInitial(ini, snapshot());
    el.badge.textContent = 'ä¿å­˜ã—ã¾ã—ãŸ';
    speak('ä¿å­˜ã—ã¾ã—ãŸ');
  });

  el.loadLocal.addEventListener('click', () => {
    const ini = getInitial();
    if (!ini) { alert('åˆ©ç”¨è€…ï¼ˆã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
    const saved = loadForInitial(ini);
    if (!saved) { alert('ä¿å­˜ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
    fillFromSaved(saved);
    el.badge.textContent = 'èª­ã¿è¾¼ã¿ã¾ã—ãŸ';
    speak('èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
  });

  const MODE = { IDLE:'idle', NAME:'name', S:'s', O:'o', A:'a', P:'p' };
  let mode = MODE.IDLE;

  const setMode = (m) => {
    mode = m;
    const labelMap = {
      [MODE.IDLE]: 'å¾…æ©Ÿä¸­',
      [MODE.NAME]: 'å…¥åŠ›ï¼šåˆ©ç”¨è€…åï¼ˆã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ï¼‰',
      [MODE.S]: 'å…¥åŠ›ï¼šS',
      [MODE.O]: 'å…¥åŠ›ï¼šO',
      [MODE.A]: 'å…¥åŠ›ï¼šA',
      [MODE.P]: 'å…¥åŠ›ï¼šP',
    };
    const label = labelMap[m] || 'å¾…æ©Ÿä¸­';
    el.badge.textContent = label;
    speak(label);
  };
  setMode(MODE.IDLE);

  const norm = (s) => (s || '')
    .trim()
    .replace(/[ï¼!ã€‚ï¼\.]/g,'')
    .replace(/[ã€ï¼Œ]/g,' ')
    .replace(/\s+/g,' ')
    .toLowerCase();

  const includesAny = (t, arr) => arr.some(w => t.includes(w));

  const isStart = (t) => includesAny(t, ['é–‹å§‹','ã‚¹ã‚¿ãƒ¼ãƒˆ','ã¯ã˜ã‚','ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹','é–‹å§‹ã™ã‚‹']);
  const isEnd   = (t) => includesAny(t, ['çµ‚ã‚ã‚Š','ãŠã‚ã‚Š','çµ‚äº†','ã—ã‚…ã†ã‚Šã‚‡ã†','å®Œäº†']);
  const isSame  = (t) => includesAny(t, ['å…¨éƒ¨å¤‰ã‚ã‚Šãªã—','ãœã‚“ã¶ã‹ã‚ã‚Šãªã—','å…¨éƒ¨åŒã˜','å‰å›ã¨åŒã˜','å…¨ã¦åŒã˜','å¤‰ã‚ã‚Šãªã—']);

  const wantS = (t) => includesAny(t, ['s','ãˆã™','ã‚¨ã‚¹','ãˆã™ã„ã“ã†','ä¸»è¦³','ã—ã‚…ã‹ã‚“']);
  const wantO = (t) => includesAny(t, ['o','ãŠãƒ¼','ã‚ªãƒ¼','å®¢è¦³','ãã‚ƒã£ã‹ã‚“']);
  const wantA = (t) => includesAny(t, ['a','ãˆãƒ¼','ã‚¨ãƒ¼','è©•ä¾¡','ã²ã‚‡ã†ã‹','ã‚ã›ã™','ã‚¢ã‚»ã‚¹']);
  const wantP = (t) => includesAny(t, ['p','ã´ãƒ¼','ãƒ”ãƒ¼','è¨ˆç”»','ã‘ã„ã‹ã','ã·ã‚‰ã‚“','ãƒ—ãƒ©ãƒ³']);

  const isNext = (t) => includesAny(t, ['æ¬¡','ã¤ã','ç¢ºå®š','ã‹ãã¦ã„','ok','ã‚ªãƒƒã‚±ãƒ¼','äº†è§£','ã‚Šã‚‡ã†ã‹ã„']);

  const nextMode = (m) => {
    if (m === MODE.S) return MODE.O;
    if (m === MODE.O) return MODE.A;
    if (m === MODE.A) return MODE.P;
    if (m === MODE.P) return MODE.IDLE;
    return m;
  };

  const append = (targetEl, rawText) => {
    const text = (rawText || '').trim();
    if (!text) return;
    if (['æ¬¡','ã¤ã','ç¢ºå®š','ã‹ãã¦ã„','ok','ã‚ªãƒƒã‚±ãƒ¼','çµ‚ã‚ã‚Š','ãŠã‚ã‚Š','çµ‚äº†','ã—ã‚…ã†ã‚Šã‚‡ã†'].includes(text)) return;

    if (targetEl.value && !targetEl.value.endsWith('\n')) targetEl.value += '\n';
    targetEl.value += text;
  };

  const applySameAsSaved = () => {
    const ini = getInitial();
    if (!ini) { speak('åˆ©ç”¨è€…åãŒæœªå…¥åŠ›ã§ã™'); return; }
    const saved = loadForInitial(ini);
    if (!saved) { speak('ä¿å­˜ãŒã‚ã‚Šã¾ã›ã‚“'); return; }

    el.date.value = today();
    fillFromSaved(saved);
    el.date.value = today();
    renderAndCopy();
    setMode(MODE.IDLE);
  };

  const onNameSpoken = (raw) => {
    const name = (raw || '').trim();
    if (!name) return;
    el.client.value = name;
    el.date.value = today();

    const saved = loadForInitial(name);
    if (saved) fillFromSaved(saved);

    setMode(MODE.S);
  };

  const handleText = (raw) => {
    const t = norm(raw);
    if (!t) return;

    if (isStart(t)) { setMode(MODE.NAME); return; }
    if (isSame(t))  { applySameAsSaved(); return; }

    if (isEnd(t)) {
      const missing = [];
      if (!el.s.value.trim()) missing.push('S');
      if (!el.o.value.trim()) missing.push('O');
      if (!el.a.value.trim()) missing.push('A');
      if (!el.p.value.trim()) missing.push('P');

      if (missing.length) {
        const msg = `${missing.join('ãƒ»')}ãŒæœªå…¥åŠ›ã§ã™`;
        el.badge.textContent = msg;
        speak(msg);
        return;
      }

      renderAndCopy();
      setMode(MODE.IDLE);
      return;
    }

    if (wantS(t)) { setMode(MODE.S); return; }
    if (wantO(t)) { setMode(MODE.O); return; }
    if (wantA(t)) { setMode(MODE.A); return; }
    if (wantP(t)) { setMode(MODE.P); return; }

    if (mode === MODE.NAME) { onNameSpoken(raw); return; }

    if (mode === MODE.S) { append(el.s, raw); if (isNext(t)) setMode(nextMode(mode)); return; }
    if (mode === MODE.O) { append(el.o, raw); if (isNext(t)) setMode(nextMode(mode)); return; }
    if (mode === MODE.A) { append(el.a, raw); if (isNext(t)) setMode(nextMode(mode)); return; }
    if (mode === MODE.P) { append(el.p, raw); if (isNext(t)) setMode(nextMode(mode)); return; }
  };

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec = null;
  let listening = false;

  const startRec = () => {
    if (!SR) { alert('ã“ã®ç«¯æœ«/ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯éŸ³å£°èªè­˜ãŒä½¿ãˆãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆChromeæ¨å¥¨ï¼‰'); return; }
    rec = new SR();
    rec.lang = 'ja-JP';
    rec.interimResults = false;
    rec.continuous = true;

    rec.onresult = (e) => {
      const last = e.results[e.results.length - 1];
      const text = last && last[0] ? last[0].transcript : '';
      if (text) handleText(text);
    };

    rec.onend = () => {
      if (listening) { try { rec.start(); } catch {} }
    };

    try { rec.start(); } catch {}
  };

  const stopRec = () => {
    try { if (rec) rec.stop(); } catch {}
    rec = null;
  };

  el.micBtn.addEventListener('click', () => {
    listening = !listening;
    el.micBtn.textContent = listening ? 'â–  éŸ³å£°åœæ­¢' : 'ğŸ™ éŸ³å£°é–‹å§‹';
    if (listening) { startRec(); speak('éŸ³å£°å…¥åŠ›ã‚’é–‹å§‹ã—ã¾ã—ãŸ'); }
    else { stopRec(); speak('éŸ³å£°å…¥åŠ›ã‚’åœæ­¢ã—ã¾ã—ãŸ'); }
  });

  el.date.value = today();
})();
</script>
</body>
</html>
